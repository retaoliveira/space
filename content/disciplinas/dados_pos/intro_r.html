---
date: 2019-05-05T00:00:00+01:00
draft: false
menu:
  dados_pos:
    parent: Unidade 1 - Análise de dados para gestão
    weight: 11
title: Conhecendo o R
type: docs
editor_options: 
  markdown: 
    wrap: 70
output: 
  blogdown::html_page:
    toc: true
weight: 13
---

<script src="/places/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#tldr">TL;DR</a></li>
<li><a href="#r-o-que-é-o-r">R? O que é o R?</a>
<ul>
<li><a href="#conhecendo-o-r">Conhecendo o R</a>
<ul>
<li><a href="#interface-e-funcionalidades">Interface e funcionalidades</a></li>
</ul></li>
</ul></li>
<li><a href="#definições-básicas">Definições básicas</a>
<ul>
<li><a href="#tipos-de-arquivos-no-r">Tipos de arquivos no R</a></li>
<li><a href="#local-de-trabalho">Local de trabalho</a></li>
<li><a href="#variáveis-funções-e-packages">Variáveis, funções e <em>packages</em></a></li>
</ul></li>
<li><a href="#r-como-calculadora">R como calculadora</a></li>
<li><a href="#utilizando-variáveis">Utilizando variáveis</a></li>
<li><a href="#tipos-de-dados-no-r">Tipos de dados no R</a>
<ul>
<li><a href="#character">Character</a></li>
<li><a href="#numeric">Numeric</a></li>
<li><a href="#logical">Logical</a></li>
<li><a href="#fatores">Fatores</a></li>
</ul></li>
<li><a href="#tipos-de-classes-no-r">Tipos de classes no R</a>
<ul>
<li><a href="#vetores">Vetores</a>
<ul>
<li><a href="#sequências">Sequências</a></li>
<li><a href="#operações-matemáticas-com-vetores">Operações matemáticas com vetores</a></li>
<li><a href="#nomes-do-vetor">Nomes do vetor</a></li>
<li><a href="#classes-dos-vetores-atômicos">Classes dos vetores atômicos</a></li>
<li><a href="#operações-entre-vetores">Operações entre vetores</a></li>
<li><a href="#subconjunto-de-um-vetor---parte-1">Subconjunto de um vetor - parte 1</a></li>
<li><a href="#soma-média-e-estatísticas-descritivas-dos-elementos-de-um-vetor">Soma, média e estatísticas descritivas dos elementos de um vetor</a></li>
<li><a href="#subconjunto-de-um-vetor---parte-2">Subconjunto de um vetor - parte 2</a></li>
</ul></li>
<li><a href="#listas">Listas</a></li>
<li><a href="#matrizes">Matrizes</a></li>
<li><a href="#dataframes">Dataframes</a>
<ul>
<li><a href="#do-editor-de-planilhas-ao-r---parte-1">Do editor de planilhas ao R - parte 1</a></li>
</ul></li>
</ul></li>
</ul>
</div>

<div id="tldr" class="section level1">
<h1>TL;DR</h1>
<p>Nessa seção apresentamos alguns conceitos importantes para que a utilização do <code>R</code> seja mais amigável! Algumas informações importantes que são detalhadas a seguir:</p>
<ul>
<li>O <code>RStudio</code> é uma interface para uso do <code>R</code></li>
<li>O <code>R</code> é sensível a caracteres maiúsculos e minúsculos.</li>
<li>Marcador de decimal para o R é <code>.</code>, mas pode ser configurado conforme arquivo.</li>
<li>O <code>R</code> é estruturado em <code>package::função(objeto, parâmetros))</code></li>
<li>Para utilizar pacotes, precisamos instalar (<code>install.packages("package")</code>), carregar (<code>library("package")</code>) e chamar as funções.<br />
</li>
<li>As funções <code>getwd()</code>, <code>dir()</code> e <code>setwd()</code> ajudam a organizar o trabalho.</li>
<li>O <code>R</code> funciona como calculadora</li>
<li>Para atribuir variáveis (objetos) ao ambiente de trabalho, você pode usar tanto <code>&lt;-</code> como <code>=</code></li>
<li>Os tipos de dados mais comuns são <code>character</code>, <code>numeric</code>, <code>factor</code>e <code>logical</code>.</li>
<li>Para fazer a conversão entre tipos de dados, podemos utilizar funções com a estrutura <code>as.tipo(objeto)</code>. Para verificar qual o tipo de dados, a função é análoga, mas <code>is.tipo(objeto)</code>. Exemplos: <code>as.logical(x)</code> e <code>is.logical(x)</code>.</li>
<li>As classes de organização dos dados mais comuns são <code>vector</code>, <code>list</code>, <code>matrix</code> e <code>dataframe</code>.</li>
<li>Parênteses são utilizados para delimitar funções e objetos/parâmetros. Colchetes são utilizados para delimitar índices de posição.</li>
<li>Existem pacotes no R que possuem bases de dados para aprendizagem. O mais conhecido pode ser obtido por <code>data(mtcars)</code>.</li>
<li>Algumas funções interessantes para conhecermos e inspecionar inicialmente os dados são:
<ul>
<li><code>head(mtcars)</code> - apresenta as seis primeiras linhas do banco de dados</li>
<li><code>str(mtcars)</code> - mostra os tipos de variáveis e a estrutura do dado</li>
<li><code>class(mtcars)</code> - mostra a classe da base de dados</li>
<li><code>dim(mtcars)</code> - mostra a dimensão do objeto</li>
<li><code>names(mtcars)</code> - mostra os nomes das variáveis (colunas)</li>
</ul></li>
<li>A função <code>c()</code> permite a construção de vetores por meio alocação de valores em posições distintas de vetores.</li>
</ul>
</div>
<div id="r-o-que-é-o-r" class="section level1">
<h1>R? O que é o R?</h1>
<div id="conhecendo-o-r" class="section level2 tabset tabset-fade tabset-pills">
<h2>Conhecendo o R</h2>
<div id="interface-e-funcionalidades" class="section level3">
<h3>Interface e funcionalidades</h3>
<p>Para uso do R no ambiente RStudio, é inicialmente necessário entender o seu funcionamento. O R é uma linguagem de programação, em plataforma open source, desenvolvida para análise de dados. SEJAM BEM VINDOS!</p>
<div class="figure">
<img src="https://retaoliveira.github.io/relements/figures/allison_horst/welcome_to_rstats_twitter.png" alt="" />
<p class="caption">Bem vindo</p>
</div>
<p>Em um primeiro momento, o conjunto R + RStudio parece pouco amigável, mas com o tempo, é impossível não apaixonar-se pelas infinitas possibilidades que temos ao utilizar o R.</p>
<div class="figure">
<img src="https://retaoliveira.github.io/relements/figures/allison_horst/r_first_then.png" alt="" />
<p class="caption">Ódio x amor</p>
</div>
<p>A comunidade do R é bastante ampla e colaborativa. Assim: BUSQUE AJUDA!!!!!</p>
<div class="figure">
<img src="https://retaoliveira.github.io/relements/figures/allison_horst/code_hero.jpg" alt="" />
<p class="caption">Suporte</p>
</div>
</div>
</div>
</div>
<div id="definições-básicas" class="section level1">
<h1>Definições básicas</h1>
<table>
<colgroup>
<col width="37%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th>Termos</th>
<th>Definição</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Script</code></td>
<td>Os scripts são arquivos do R com comandos a serem executados. Para rodar um comando digitado no painel de edição dos Scripts ou do arquivo .Rmd do RStudio no Windows, basta fazer: <code>Ctrl+Enter</code>.</td>
</tr>
<tr class="even">
<td><code>Packages</code> ou <code>pacotes</code></td>
<td>São um conjunto de funções organizadas em um arquivo que pode ser obtido em diferentes repositórios. Para utilização dos pacotes, é necessário instalá-los e, posteriormente, carregá-los na sessão por meio do comando <code>library</code>.</td>
</tr>
<tr class="odd">
<td><code>funções</code></td>
<td>São códigos que determina um algoritmo computacional e que têm diferentes objetivos. Pode haver mais de uma função para o mesmo objetivo. As funções são estruturadas por meio de um comando básico e parâmetros/argumentos que são incluídos entre parênteses após a função.</td>
</tr>
<tr class="even">
<td><code>objeto</code></td>
<td>Objetos no R são elementos aos quais são aplicadas as funções</td>
</tr>
<tr class="odd">
<td><code>Console</code></td>
<td>É o espaço no ambiente R onde você digita e roda os comandos do R. É a janela principal, onde é possível digitar os comandos, vizualizar os resultados e mensagens de alerta e mensagens de erros. Nesse ambiente, a seta (&gt;) indica que o R esta pronto para receber um comando; sinal de mais (+) indica que o comando da linha anterior ainda não esta completo, faltando algo para o comando ser executado. A ausência de um desses dois simbólos (&gt; ou +) indica que o R ainda não finalizou o processo do comando anterior. Os resultados de uma função são apresentados entre símbolos de cochetes ([]).</td>
</tr>
<tr class="even">
<td><code>Terminal</code></td>
<td>É o espaço onde você digita e roda comandos do sistema (Windows, por exemplo)</td>
</tr>
<tr class="odd">
<td><code>RMarkdown</code></td>
<td>Linguagem de texto do R</td>
</tr>
<tr class="even">
<td><code>RStudio</code></td>
<td>É uma IDE (Integrated Development Envirnonment) que permite uma interface gráfica amigável com os usuários.</td>
</tr>
<tr class="odd">
<td><code>Help</code></td>
<td>Janela onde são mostrados os textos de ajuda.</td>
</tr>
<tr class="even">
<td><code>Plot</code></td>
<td>Janela reservada para os resultados gráficos.</td>
</tr>
<tr class="odd">
<td><code>History</code></td>
<td>Lista o histórico dos comandos já executados.</td>
</tr>
<tr class="even">
<td><code>Environment</code></td>
<td>Painel exclusivo do RStudio que lista os objetos criados na área de trabalho (workspace).</td>
</tr>
<tr class="odd">
<td><code>Files</code></td>
<td>Painel exclusivo do RStudio, que lista os arquivos do computador. É semelhante ao gerenciador de arquivos padrão do sistema operacional.</td>
</tr>
</tbody>
</table>
<div id="tipos-de-arquivos-no-r" class="section level2">
<h2>Tipos de arquivos no R</h2>
<p>Os principais tipos de arquivos gerados por meio do <code>R</code> são:</p>
<table>
<thead>
<tr class="header">
<th>Extensão</th>
<th>Descrição</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.R</td>
<td>Usado para salvar <code>scripts</code>.</td>
</tr>
<tr class="even">
<td>.RData</td>
<td>Usado para salvar os <code>objetos</code> da área de trabalho (workspace).</td>
</tr>
<tr class="odd">
<td>.Rhistory</td>
<td>Usado para salvar o <code>histórico dos comandos</code> executados.</td>
</tr>
<tr class="even">
<td>.Rmd</td>
<td>Formato para salvar arquivos em <code>RMarkdown</code></td>
</tr>
</tbody>
</table>
</div>
<div id="local-de-trabalho" class="section level2">
<h2>Local de trabalho</h2>
<p>O diretório de trabalho padrão é aquele ao qual o R foi associado. Entretanto, pode ser alterado, sem qualquer mudanças nos objetos da área de trabalho.</p>
<p><img src="https://retaoliveira.github.io/relements/figures/allison_horst/cracked_setwd.png" /></p>
<pre class="r"><code>getwd() # Mostrar o diretório de trabalho atual
dir() # Listar os arquivos do diretório
setwd() # Mudar o diretório de trabalho</code></pre>
<p>É possivel salvar a área de trabalho inteira e carregar em outro momento.</p>
<pre class="r"><code>ls() # Listar os objetos da área de trabalho
save.image(&quot;meu_workspace.RData&quot;) # Salvar área de trabalho
load(&quot;meu_workspace.RData&quot;) # Carregar área de trabalho</code></pre>
</div>
<div id="variáveis-funções-e-packages" class="section level2">
<h2>Variáveis, funções e <em>packages</em></h2>
<p>Sua estrutura fundamenta-se em uma grande variedade de ferramentas quantitativas, organizadas por meio de <strong>objetos</strong>, <strong>funções</strong> e <strong>packages</strong>. A instalação <code>base</code> do R já contempla uma série de funções e <em>packages</em>. <em>Packages</em> adicionais podem ser instalados quando for necessário ou interessante. Para instalação de <em>packages</em>, utiliza-se a função <code>install.packages()</code>.</p>
<p>A priori, instale os seguintes pacotes no seu computador:</p>
<pre class="r"><code>install.packages(c(&quot;rmarkdown&quot;, &quot;knitr&quot;, &quot;dsbox&quot;, &quot;tidyverse&quot;, &quot;coronavirus&quot;, &quot;lubridate&quot;, &quot;glue&quot;, &quot;scales&quot;, &quot;ggrepel&quot;, &quot;DT&quot;, &quot;flexdashboard&quot;, &quot;blogdown&quot;, &quot;bookdown&quot;, &quot;pagedown&quot;, &quot;xaringan&quot;, &quot;xaringanthemer&quot;, &quot;janitor&quot;, &quot;jsonlite&quot;, &quot;kableExtra&quot;, &quot;leaflet&quot;, &quot;officedown&quot;, &quot;openxlsx&quot;, &quot;readr&quot;, &quot;readxl&quot;, &quot;devtools&quot;, &quot;remotes&quot;, &quot;swirl&quot;, &quot;stringr&quot;, &quot;tmap&quot;, &quot;tmapstool&quot;, &quot;rvest&quot;, &quot;viridis&quot;, &quot;installr&quot;, &quot;distill&quot;, &quot;rticles&quot;, &quot;data.table&quot;, &quot;ggplot2&quot;, &quot;hrbrthemes&quot;, &quot;plotly&quot;, &quot;learnr&quot;, &quot;prettydoc&quot;, &quot;corrplot&quot;, &quot;tufte&quot;, &quot;ggpubr&quot;, &quot;sf&quot;, &quot;htmlwidgets&quot;))</code></pre>
<p>Ao longo do curso chamaremos as bibliotecas para que possamos implementar as funções.</p>
</div>
</div>
<div id="r-como-calculadora" class="section level1">
<h1>R como calculadora</h1>
<p>No <code>R</code> você pode fazer cálculos simples usando o console.</p>
<p>R serve como calculadora é bastante simples realizar operações matemáticas.</p>
<p>Soma:</p>
<pre class="r"><code>42 + 84</code></pre>
<pre><code>## [1] 126</code></pre>
<p>Subtração:</p>
<pre class="r"><code>84 - 42</code></pre>
<pre><code>## [1] 42</code></pre>
<p>Multiplicação</p>
<pre class="r"><code>42 * 2</code></pre>
<pre><code>## [1] 84</code></pre>
<p>Divisão:</p>
<pre class="r"><code>42 / 6</code></pre>
<pre><code>## [1] 7</code></pre>
<p>Potência:</p>
<pre class="r"><code>2 ^ 5</code></pre>
<pre><code>## [1] 32</code></pre>
<p>Divisão inteira (sem resto):</p>
<pre class="r"><code>42 %/% 5</code></pre>
<pre><code>## [1] 8</code></pre>
<p>Resto da divisão:</p>
<pre class="r"><code>42 %% 5</code></pre>
<pre><code>## [1] 2</code></pre>
</div>
<div id="utilizando-variáveis" class="section level1">
<h1>Utilizando variáveis</h1>
<p>Nos exemplos acima realizamos operações bastante simples sem usar objetos, ou, como costumamos chamar, variáveis.</p>
<p>Vamos criar uma variável “x” com o valor 42. Ao criar uma variável que armazena apenas um número, estamos criando um vetor atômico (pois vetores atômicos são os vetores de tamanho 1).</p>
<pre class="r"><code>x &lt;- 42</code></pre>
<p>Lembre-se: podemos usar o “&lt;-” ou “=” para fazermos uma atribuição:</p>
<pre class="r"><code>x = 42</code></pre>
<p>No entanto, vale a pena usar “&lt;-” para não confundir os usos de “=”, que também é usado para estabelecer valores nos argumentos de uma função.</p>
<p>Podemos imprimir o valor de uma variável no console simplesmente digitando seu nome:</p>
<pre class="r"><code>x</code></pre>
<pre><code>## [1] 42</code></pre>
<p>Em várias outras linguagens, e em R inclusive, usa-se a função <em>print</em> para imprimir os valores de uma variável:</p>
<pre class="r"><code>print(x)</code></pre>
<pre><code>## [1] 42</code></pre>
<p>Quando usar print? Veremos no futuro que, dependendo da situação (por exemplo, dentro de funções), é preciso explicitar que queremos “imprimir” algo, e, nestes casos, usamos a função <em>print</em>.</p>
<p>Vamos criar mais uma variável, y, e fazer operações com variáveis:</p>
<pre class="r"><code>y &lt;- 5
x + y</code></pre>
<pre><code>## [1] 47</code></pre>
<pre class="r"><code>x - y</code></pre>
<pre><code>## [1] 37</code></pre>
<pre class="r"><code>x / y</code></pre>
<pre><code>## [1] 8.4</code></pre>
<pre class="r"><code>x * y</code></pre>
<pre><code>## [1] 210</code></pre>
<p>Podemos armazenar o resultado de uma operação matemática em uma variável. Veja os exemplos:</p>
<pre class="r"><code>z1 &lt;- 42 / 3
z2 &lt;- x + y
z3 &lt;- ((x / 5 ) * 9) + 32</code></pre>
<p>Veja que na última operação utilizamos diversos parênteses. As regras para o uso de parênteses no R em operações matemáticas são semelhantes às da “aritmética de papel e caneta”. Os parênteses são executados sempre de dentro para fora. Aliás, essa regra vale em geral no R, ou seja, para aplicação de quaisquer funções, e não apenas para as operações matemáticas.</p>
</div>
<div id="tipos-de-dados-no-r" class="section level1">
<h1>Tipos de dados no R</h1>
<p>No R, os dados são organizados por meio de uma estrutura hierárquica de tipos de dados que podem ser utilizados para armazenar valores em diferentes estruturas. Cada tipo de dado pode ser associado com uma função de teste e uma função de conversão.</p>
<p>A função de teste retorna sempre <code>TRUE</code> ou <code>FALSE</code>, pois é uma <code>função lógica</code>.</p>
<p>A função de conversão, quando possível, transforma os dados em diferentes tipos.</p>
<p>Funções de teste apresentam a estrutura <code>is.character()</code> e funções de conversão são <code>as.character()</code>.</p>
<p>Neste curso não detalharemos todos os tipos de dados, mas apresentaremos apenas os mais importantes para a análise de dados em caráter exploratório. No blog, temos diversas sugestões de tutoriais e documentação geral que contempla todos os tipos de dados e capacidade de interoperabilidade do R.</p>
<div id="character" class="section level3">
<h3>Character</h3>
<p>Variáveis <code>character</code> são aquelas que contém texto. Para designar uma variável como texto, precisamos colocar seus valores entre aspas. Dados do tipo texto são comuns em variáveis categóricas.</p>
<p>Experimente:</p>
<pre class="r"><code>d &lt;- &quot;texto&quot;
is.character(d)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="numeric" class="section level3">
<h3>Numeric</h3>
<p>Dados <code>numeric</code> são números. A função <code>numeric</code> pode ser utilizada para gerar um vetor com elementos numéricos com valor 0.</p>
<p>Faça:</p>
<pre class="r"><code># Criar vetor de cinco posições com valores 0
numeric(5)</code></pre>
<pre><code>## [1] 0 0 0 0 0</code></pre>
<pre class="r"><code># Gera valor character
e &lt;- &quot;1980&quot;

# Teste
is.numeric(e)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code># Conversão
f &lt;- as.numeric(&quot;1980&quot;)

# Teste
is.numeric(f)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="logical" class="section level3">
<h3>Logical</h3>
<p>A função <code>logical</code> gera um vetor lógico com o tamanho desejado e por padrão, cada elemento do vetor recebe o valor <code>FALSE</code>.</p>
<pre class="r"><code>logical(3)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE</code></pre>
<pre class="r"><code># Conversão
as.logical(c(7,5,0))</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE</code></pre>
<pre class="r"><code># TRUE e FALSE podem ser convertidos em 1 ou 0
as.logical(c(7,5,0))*1</code></pre>
<pre><code>## [1] 1 1 0</code></pre>
<p>Os valores no vetor que são diferentes de <em>zero</em>, recebem o valor <code>TRUE</code>.</p>
<blockquote>
<p>A função <strong><code>c</code></strong>(<em>combine</em>) é utilizada para composição de um vetor, combinando valores identificados por índices.</p>
</blockquote>
</div>
<div id="fatores" class="section level2">
<h2>Fatores</h2>
<p>Neste tutorial, falamos rapidamente de classe e o assunto pareceu relativamente simples. Vamos complicá-lo com um dos aspectos mais confusos da linguagem R: a classe de vetores <strong>factor</strong>.</p>
<p><strong>factor</strong> é, basicamente, a classe de vetores em R utilizada para lidar com dados categóricos, nominais ou ordinais. Em vez de gastarmos tinta tentando entendê-los de forma abstrata, vamos a um exemplo.</p>
<p>Suponhamos que temos um vetor de texto que representa uma variável categórica que pode receber dois valores, “sim” e “nao”.</p>
<pre class="r"><code>yes_no &lt;- c(&quot;sim&quot;, &quot;nao&quot;, &quot;nao&quot;, &quot;nao&quot;, &quot;sim&quot;, &quot;nao&quot;)
print(yes_no)</code></pre>
<pre><code>## [1] &quot;sim&quot; &quot;nao&quot; &quot;nao&quot; &quot;nao&quot; &quot;sim&quot; &quot;nao&quot;</code></pre>
<pre class="r"><code>class(yes_no)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>Vamos usar a função <em>factor</em> para gerar o vetor “f_yes_no” e observar o resultado:</p>
<pre class="r"><code>f_yes_no &lt;- factor(yes_no)
print(f_yes_no)</code></pre>
<pre><code>## [1] sim nao nao nao sim nao
## Levels: nao sim</code></pre>
<p>Note que não temos mais aspas nos valores impressos do vetor de fatores. Além disso, ele vem acompanhado de uma nova informação: “levels”, ou niveis.</p>
<p>Basicamente, “factors” são vetores numéricos cujos valores estão associados a um rótulo. Os “levels” são esses pares de código numérico + rótulo.</p>
<p>Se tentamos transformar em números o vetor de fatores, veja o que obtemos:</p>
<pre class="r"><code>as.numeric(f_yes_no)</code></pre>
<pre><code>## [1] 2 1 1 1 2 1</code></pre>
<p>1 e 2 são os códigos numéricos gerados autormaticamente para “nao” e “sim”, respectivamente. O critério para atribuir valores foi a ordem alfabética dos textos transformados em fatores.</p>
<p>Podemos investigar os níveis de um vetor de fatores com a função <em>levels</em>:</p>
<pre class="r"><code>levels(f_yes_no)</code></pre>
<pre><code>## [1] &quot;nao&quot; &quot;sim&quot;</code></pre>
<p>E também podemos alterá-los, tal como fazemos com os nomes dos elementos de um vetor:</p>
<pre class="r"><code>levels(f_yes_no) &lt;- c(&quot;No&quot;, &quot;Sim&quot;)
print(f_yes_no)</code></pre>
<pre><code>## [1] Sim No  No  No  Sim No 
## Levels: No Sim</code></pre>
<p>Tudo bem até agora?</p>
<p>E se os níveis de uma variável forem ordenados? Vejamos um exemplo:</p>
<pre class="r"><code>tamanho &lt;- c(&quot;alto&quot;, &quot;baixo&quot;, &quot;baixo&quot;, &quot;medio&quot;, &quot;alto&quot;, &quot;baixo&quot;, &quot;medio&quot;)
f_tamanho &lt;- factor(tamanho)
print(f_tamanho)</code></pre>
<pre><code>## [1] alto  baixo baixo medio alto  baixo medio
## Levels: alto baixo medio</code></pre>
<p>Como o R segue o ordenamento alfabético, os códigos numéricos 1, 2 e 3 estão associados a “alto”, “baixo” e “medio”, respectivamente. Mas qual é o problema de não ordenarmos? Veja abaixo:</p>
<pre class="r"><code>f_tamanho[1]</code></pre>
<pre><code>## [1] alto
## Levels: alto baixo medio</code></pre>
<pre class="r"><code>f_tamanho[2]</code></pre>
<pre><code>## [1] baixo
## Levels: alto baixo medio</code></pre>
<pre class="r"><code>f_tamanho[1] &gt; f_tamanho[2]</code></pre>
<pre><code>## Warning in Ops.factor(f_tamanho[1], f_tamanho[2]): &#39;&gt;&#39; not meaningful for
## factors</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Sem ordenarmos, não podemos comparar os níveis e estamos assumindo a variável como sendo nominal.</p>
<p>Para ordernar os níveis de um vetor de fatores, temos que informar alguns parâmetros adicionais – <em>order</em> e <em>levels</em> – ao criá-lo:</p>
<pre class="r"><code>f_tamanho &lt;- factor(tamanho, ordered = T, levels &lt;- c(&quot;baixo&quot;, &quot;medio&quot;, &quot;alto&quot;))
print(f_tamanho)</code></pre>
<pre><code>## [1] alto  baixo baixo medio alto  baixo medio
## Levels: baixo &lt; medio &lt; alto</code></pre>
<p>Note que a informação sobre os “levels” acompanha a ordem informada, que, neste caso, é diferente da alfabética. Comparações entre os níveis fazem sentido se a variável for ordinal:</p>
<pre class="r"><code>f_tamanho[1]</code></pre>
<pre><code>## [1] alto
## Levels: baixo &lt; medio &lt; alto</code></pre>
<pre class="r"><code>f_tamanho[2]</code></pre>
<pre><code>## [1] baixo
## Levels: baixo &lt; medio &lt; alto</code></pre>
<pre class="r"><code>f_tamanho[1] &gt; f_tamanho[2]</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>f_tamanho &gt; &quot;medio&quot;</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE</code></pre>
<p>Voltaremos aos “factors” em momento adequado. O importante agora é saber que eles existem e que é uma classe de vetores em R. Atenção especial deve ser dada ao fato de que diversas vezes, ao importarmos bases de dados para o “workspace”, o R considera variáveis de texto como sendo “factors”, mesmo de maneira inadequada. Para evitar este problema, devemos adotar o argumento “stringAsFactors = F” em diversas funções de importação. Como avisei no início deste tópico, “factors” é um dos aspectos mais confusos em R (em conjunto com “missing values”, que vamos adiar até um momento adequado).</p>
<p>Em síntese:</p>
<p>Fatores são vetores de categorias específicas, definidas por meio do parâmetro <code>levels</code>. A ordem dos fatores pode ser especificada pela função <code>ordered</code>. Experimente:</p>
<pre class="r"><code># Vetor de texto
tipos.casas &lt;- c(&quot;casa&quot;, &quot;apartamento&quot;, &quot;apartamento&quot;, &quot;sobrado&quot;)

# Vetor de fatores
tipos.casas &lt;- factor(c(&quot;casa&quot;, &quot;apartamento&quot;, &quot;apartamento&quot;, &quot;sobrado&quot;), levels=c(&quot;casa&quot;, &quot;apartamento&quot;, &quot;sobrado&quot;))</code></pre>
<p>Quando utilizamos dados em estrutura de fatores, é possível gerar sínteses rápidas e simples por meio da função <code>table</code>.</p>
<pre class="r"><code>table(tipos.casas)</code></pre>
<pre><code>## tipos.casas
##        casa apartamento     sobrado 
##           1           2           1</code></pre>
<p>Dados fatoriais são úteis para o tratamento de dados categóricos, ou que pertencem a um determinado número de classes predeterminadas. Existem muitas feições representadas por meio de dados espaciais que são estruturadas em variáveis discretas.</p>
<p>LEMBRANDO….. Dados podem ser:
<img src="https://retaoliveira.github.io/relements/figures/continuous_discrete.png" alt="Discretos x Contínuos" />
<img src="https://retaoliveira.github.io/relements/figures/nominal_ordinal_binary.png" alt="Discreto x Contínuo" /></p>
<p>Para ordenar dados fatoriais, utilizamos a função <code>ordered</code>.</p>
<pre class="r"><code>renda_1 &lt;- factor(c(&quot;alta&quot;, &quot;alta&quot;, &quot;baixa&quot;, &quot;baixa&quot;, &quot;media&quot;, &quot;alta&quot;), levels=c(&quot;baixa&quot;, &quot;media&quot;, &quot;alta&quot;)) 

renda_2 &lt;- ordered(c(&quot;alta&quot;, &quot;alta&quot;, &quot;baixa&quot;, &quot;baixa&quot;, &quot;media&quot;, &quot;alta&quot;), levels=c(&quot;baixa&quot;, &quot;media&quot;, &quot;alta&quot;)) </code></pre>
</div>
</div>
<div id="tipos-de-classes-no-r" class="section level1">
<h1>Tipos de classes no R</h1>
<p>Diferentes tipos de dados podem ser utilizados para popular diferentes estruturas de dados ou <code>classes</code>. As classes mais comumente utilizadas para análise de dados espaciais são: vetores, matrizes, data frames, listas e factores.</p>
<p>É por meio das classes que as funções e operadores conseguem saber exatamente o que fazer com um objeto.</p>
<p>Experimente:</p>
<pre class="r"><code>1+1</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Faça <code>"a" + "b"</code></p>
<p>O operador <code>+</code> verifica que “a” e “b” não são números (ou que não são do tipo <code>numeric</code>) e devolve uma mensagem de erro informando isso.</p>
<div id="vetores" class="section level2">
<h2>Vetores</h2>
<p>O R é construído com base no conceito de vetores e matrizes. As maior parte das operações é feita para os elementos.</p>
<pre class="r"><code># Definição de vetores
vector(mode = &quot;numeric&quot;, length = 8)</code></pre>
<pre><code>## [1] 0 0 0 0 0 0 0 0</code></pre>
<pre class="r"><code>vector(length = 8)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>tmp &lt;- data.frame(a=10:15, b=15:20)</code></pre>
<p>Aproveitando o embalo dos vetores atômicos, vamos ver um pouco mais sobre vetores de tamanho maior que 1. Alguns exemplos e suas classes:</p>
<pre class="r"><code>vetor_numerico &lt;- c(42, 7, 999, 3.14)
vetor_texto &lt;- c(&quot;Miriam&quot;, &quot;a&quot;, &#39;jota&#39;, &quot;TRUE&quot;, &quot;4&quot;)
vetor_logico &lt;- c(TRUE, FALSE, F, F, T)
class(vetor_numerico)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>class(vetor_texto)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>class(vetor_logico)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<p>Detalhes para observarmos:</p>
<ul>
<li>No caso do vetor numérico, não importa se usamos números com casas decimais.</li>
<li>Para vetores do tipo “character”, não importa o que há dentro dos parêntese. Tudo é texto.</li>
<li>Você pode usar TRUE ou T, FALSE ou F, alternadamente. O R entende o que você quer dizer. Lembre-se de sempre usar maiúsculas.</li>
</ul>
<div id="sequências" class="section level3">
<h3>Sequências</h3>
<p>Dá um trabalho danado criar uma sequência de números de, por exemplo, 42 a 66. Ou sequências ainda maiores. Uma maneira simples (mas não a única), de gerar uma sequência de inteiros em R é utilizar “:”. Veja o exemplo:</p>
<pre class="r"><code>sequencia &lt;- 42:66
print(sequencia)</code></pre>
<pre><code>##  [1] 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66</code></pre>
<p>A sequência pode ter ordem reversa:</p>
<pre class="r"><code>sequencia_reversa &lt;- 10:1
print(sequencia_reversa)</code></pre>
<pre><code>##  [1] 10  9  8  7  6  5  4  3  2  1</code></pre>
<p>Podemos combinar sequências que contém um intervalo, ou mesmo sequências que se sobrepõe, em um único vetor:</p>
<pre class="r"><code>sequencia_intervalo &lt;- c(1:10, 20:30)
print(sequencia_intervalo)</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 20 21 22 23 24 25 26 27 28 29 30</code></pre>
<pre class="r"><code>sequencia_sobreposicao &lt;- c(10:20, 15:25)
print(sequencia_sobreposicao)</code></pre>
<pre><code>##  [1] 10 11 12 13 14 15 16 17 18 19 20 15 16 17 18 19 20 21 22 23 24 25</code></pre>
</div>
<div id="operações-matemáticas-com-vetores" class="section level3">
<h3>Operações matemáticas com vetores</h3>
<p>Vamos considerar uma operação com vetores considerando a conversão de dados entre Farenheit e Celsius.</p>
<p>Temos um vetor de temperaturas médias dos meses de dezembro a abril em um lugar qualquer do hemisfério Norte:</p>
<pre class="r"><code>temperatura_celsius &lt;- c(-7, -10, 5, 12, 21)</code></pre>
<p>Da mesma maneira que com vetores atômicos, podemos aplicar as operações matemáticas a vetores maiores. Por exemplo, vamos converter os valores do vetor “temperatura_celsius” para farenheit:</p>
<pre class="r"><code>temperatura_farenheit &lt;- ((temperatura_celsius / 5) * 9) + 32</code></pre>
<p>Veja que as operações são aplicadas a todos os elementos do vetor.</p>
</div>
<div id="nomes-do-vetor" class="section level3">
<h3>Nomes do vetor</h3>
<p>Aproveitando o exemplo, os elementos de um vetor podem ser nomeados. O vetor “temperatura_celsius”, por enquanto, não tem nome:</p>
<pre class="r"><code>names(temperatura_celsius)</code></pre>
<pre><code>## NULL</code></pre>
<p>Se quiseremos atribuir os nomes aos elementos de “temperatura_celsius”, atribuimos um vetor a “names(temperatura_celsius)”. Esse uso da linguagem é um pouco estranho, pois estamos atribuindo algo a uma função de um objeto, não a um objeto.</p>
<p>Uma maneira de pensar esse uso de maneira menos confusa, é imaginar que um objeto tem várias partes e que estamos atribuindo algo a uma parte específica – os nomes dos elementos, no caso – deste objeto. Veja:</p>
<pre class="r"><code>names(temperatura_celsius) &lt;- c(&quot;dezembro&quot;, &quot;janeiro&quot;, &quot;fevereiro&quot;, &quot;março&quot;, &quot;abril&quot;)</code></pre>
<p>Outra forma, mais elegante, de nomear os elementos de um vetor é criar um novo vetor com os nomes, tal como abaixo…</p>
<pre class="r"><code>meses_experimento &lt;- c(&quot;dezembro&quot;, &quot;janeiro&quot;, &quot;fevereiro&quot;, &quot;março&quot;, &quot;abril&quot;)</code></pre>
<p>… e a seguir atribuir aos nomes dos elementos do vetor existente (no nosso caso, temperatura_celsius):</p>
<pre class="r"><code>names(temperatura_celsius) &lt;- meses_experimento</code></pre>
<p>A vantagem deste processo é poder usar mais de uma vez o vetor de nomes sem precisar escrevê-lo novamente, como faremos no exemplo abaixo.</p>
</div>
<div id="classes-dos-vetores-atômicos" class="section level3">
<h3>Classes dos vetores atômicos</h3>
<p>Há três <strong>classes</strong> fundamentais para os vetores atômicos. Vamos criar três variáveis e examinar suas classes:</p>
<pre class="r"><code>numero_pi &lt;- 3.14
texto &lt;- &quot;Meu texto&quot;
verdadeiro &lt;- TRUE</code></pre>
<p>Usamos a função <em>class</em> para examinar a classe de um objeto:</p>
<pre class="r"><code>class(numero_pi)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>class(texto)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>class(verdadeiro)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<p>Auto-explicativo, certo? De forma mais detalhada, apresentaremos os principais tipos de dados e as classes de objetos no R a seguir.</p>
</div>
<div id="operações-entre-vetores" class="section level3">
<h3>Operações entre vetores</h3>
<p>Criemos dois vetores, cada um registrando os gastos com sorvete e café de um pessoa em cada dia da semana, sábado e domingo, inclusive:</p>
<pre class="r"><code>semana_1 &lt;- c(32, 20, 15, 20, 18, 19, 40)
semana_2 &lt;- c(32, 21, 12, 12, 24, 21, 50)</code></pre>
<p>Antes de seguir com as operações entre os vetores, vamos nomear seus elementos. Vale a penas criar um único vetor, “dias_da_semana”, e atribuir aos nomes dos elementos dos vetores de dados de gasto com sorvete e café:</p>
<pre class="r"><code>dias_da_semana &lt;- c(&quot;Domingo&quot;, &quot;Segunda&quot;, &quot;Terca&quot;, &quot;Quarta&quot;, &quot;Quinta&quot;, &quot;Sexta&quot;, &quot;Sabado&quot;)
names(semana_1) &lt;- dias_da_semana 
names(semana_2) &lt;- dias_da_semana</code></pre>
<p>Operações entre vetores seguem a mesma lógica das operações com vetores atômicos e com vetores e números, com a ressalva de que as operações são realizadas “pareando” os elementos dos vetores. Dito de outra forma, ao somarmos dois vetores, por exemplo, o vetor resultante terá na primeira posição a soma dos elementos da primeira posição dos vetores originais, a segunda posição terá a soma dos elementos da segunda posição dos vetores originais e assim por diante. Executando o exemplo:</p>
<pre class="r"><code>soma_semanas &lt;- semana_1 + semana_2
print(soma_semanas)</code></pre>
<pre><code>## Domingo Segunda   Terca  Quarta  Quinta   Sexta  Sabado 
##      64      41      27      32      42      40      90</code></pre>
<p>Note que, como os vetores originais já estavam nomeados e os elementos em cada posição tinham o mesmo nome, o vetor resultante também já está nomeado.</p>
<p>É bastante simples criar um vetor que seja a combinação de dois vetores. Por exemplo, se quisermos juntar as duas semanas em um único vetor, usamos a função <em>c</em>:</p>
<pre class="r"><code>duas_semanas &lt;- c(semana_1, semana_2)</code></pre>
</div>
<div id="subconjunto-de-um-vetor---parte-1" class="section level3">
<h3>Subconjunto de um vetor - parte 1</h3>
<p>E se quisermos extrair elementos em apenas uma ou algumas posições de um vetor?</p>
<p>Quando queremos selecionar elementos de um vetor (ou, no futuro, de uma matriz ou de um <em>data frame</em>) usamos colchetes [] ao final do objeto. Vetores são objetos com uma única dimensão, então tudo que precisamos fazer é colocar o número da posição que queremos dentro dos colchetes. Chamamos esse procedimento em inglês de “subset” (no português, “selecionar um subconjunto”).</p>
<p>Para extrair o primeiro dia do vetor com dados da semana 1 (domingo):</p>
<pre class="r"><code>semana_1[1]</code></pre>
<pre><code>## Domingo 
##      32</code></pre>
<p>Ou, para extrair o final de semana (domingo na posição 1 e sábado na posição 7):</p>
<pre class="r"><code>semana_1[c(1,7)]</code></pre>
<pre><code>## Domingo  Sabado 
##      32      40</code></pre>
<p>Ou ainda, os dias úteis da semana:</p>
<pre class="r"><code>semana_1[2:6]</code></pre>
<pre><code>## Segunda   Terca  Quarta  Quinta   Sexta 
##      20      15      20      18      19</code></pre>
<p>Se os elementos do vetor estiverem adequadamente nomeados, podemos usar seus nomes no lugar de suas posições. Repetindo os dois primeiros exemplos imediatamente acima temos:</p>
<pre class="r"><code>semana_1[&quot;Domingo&quot;]</code></pre>
<pre><code>## Domingo 
##      32</code></pre>
<pre class="r"><code>semana_1[c(&quot;Domingo&quot;, &quot;Sabado&quot;)]</code></pre>
<pre><code>## Domingo  Sabado 
##      32      40</code></pre>
<p>Podemos usar um vetor para nos auxíliar a produzir o subconjunto:</p>
<pre class="r"><code>dias_uteis &lt;- c(&quot;Segunda&quot;, &quot;Terca&quot;, &quot;Quarta&quot;, &quot;Quinta&quot;, &quot;Sexta&quot;)
semana_1[dias_uteis]</code></pre>
<pre><code>## Segunda   Terca  Quarta  Quinta   Sexta 
##      20      15      20      18      19</code></pre>
</div>
<div id="soma-média-e-estatísticas-descritivas-dos-elementos-de-um-vetor" class="section level3">
<h3>Soma, média e estatísticas descritivas dos elementos de um vetor</h3>
<p>Ao longo do tempo, nosso repertório de funções de R aumentará rapidamente. Há um conjunto de funções fáceis de lembrar que são muito úteis para calcular estatísticas descritivas de um vetor (ou de uma variável em um <em>data frame</em>). Exemplo: meu consumo de litros de café por mês em 2016.</p>
<pre class="r"><code>litros_cafe &lt;- c(4.3, 3.1, 5.3, 5.5, 6.9, 8.3, 9.7, 9.9, 9.1, 7.0, 6.2, 5.6)</code></pre>
<p>Observe as funções de soma, media, desvio padrão, variância, mediana, máximo, mínimo e quantil, na respectiva ordem:</p>
<pre class="r"><code>sum(litros_cafe)</code></pre>
<pre><code>## [1] 80.9</code></pre>
<pre class="r"><code>mean(litros_cafe)</code></pre>
<pre><code>## [1] 6.741667</code></pre>
<pre class="r"><code>sd(litros_cafe)</code></pre>
<pre><code>## [1] 2.158475</code></pre>
<pre class="r"><code>var(litros_cafe)</code></pre>
<pre><code>## [1] 4.659015</code></pre>
<pre class="r"><code>median(litros_cafe)</code></pre>
<pre><code>## [1] 6.55</code></pre>
<pre class="r"><code>max(litros_cafe)</code></pre>
<pre><code>## [1] 9.9</code></pre>
<pre class="r"><code>min(litros_cafe)</code></pre>
<pre><code>## [1] 3.1</code></pre>
<pre class="r"><code>quantile(litros_cafe, probs = c(0, 0.25, 0.5, 0.75, 1))</code></pre>
<pre><code>##   0%  25%  50%  75% 100% 
## 3.10 5.45 6.55 8.50 9.90</code></pre>
<p>Veja que, com a exceção de <em>quantile</em>, todas as funções retornam vetores atômicos. <em>quantile</em> retorna um vetor do tamanho do vetor de probabilidades, que é o segundo argumento da função, e que indica os quantis correspondentes a cada valor.</p>
</div>
<div id="subconjunto-de-um-vetor---parte-2" class="section level3">
<h3>Subconjunto de um vetor - parte 2</h3>
<p>Finalmente, vamos usar operadores relacionais. A “Organização Mundial de Bebedores de Café”, OMBC, recomenda que o consumo de café não ultrapasse o limite de até 7 litros por mês (inclusive). Vamos observar o histórico em meses de consumo de café para um indivíduo.</p>
<p>Nomeando o vetor:</p>
<pre class="r"><code>meses &lt;- c(&quot;Janeiro&quot;, &quot;Fevereiro&quot;, &quot;Marco&quot;, &quot;Abril&quot;, &quot;Maio&quot;, &quot;Junho&quot;, 
           &quot;Julho&quot;, &quot;Agosto&quot;, &quot;Setembro&quot;, &quot;Outubro&quot;, &quot;Novembro&quot;, &quot;Dezembro&quot;)
names(litros_cafe) &lt;- meses</code></pre>
<p>Criando um vetor lógico (TRUE ou FALSE) que indique em quais meses o consumo ultrapassou o limite recomendado:</p>
<pre class="r"><code>selecao &lt;- litros_cafe &gt; 7
print(selecao)</code></pre>
<pre><code>##   Janeiro Fevereiro     Marco     Abril      Maio     Junho     Julho    Agosto 
##     FALSE     FALSE     FALSE     FALSE     FALSE      TRUE      TRUE      TRUE 
##  Setembro   Outubro  Novembro  Dezembro 
##      TRUE     FALSE     FALSE     FALSE</code></pre>
<p>Usamos o vetor “selecao” para fazer o subconjunto do vetor de dados de consumo de café:</p>
<pre class="r"><code>litros_cafe[selecao]</code></pre>
<pre><code>##    Junho    Julho   Agosto Setembro 
##      8.3      9.7      9.9      9.1</code></pre>
<p>Para vetores pequenos, o procedimento adotado para gerar subconjuntos parece desnecessariamente trabalhoso. Mas imagine agora que você queira observar os votos de todos os candidatos que atendam a determinada condição – por exemplo, terem gastos de campanha acima de determinado patarmar. Com uma variável (gasto de campanha) você pode gerar um vetor de seleção que permite gerar o subconjunto desejado.</p>
<p>Voltaremos em variações desse assunto em diversos momentos no futuro.</p>
</div>
</div>
<div id="listas" class="section level2">
<h2>Listas</h2>
<p>Os tipos de dados <code>character</code>, <code>numeric</code> e <code>logical</code> só podem ser associados a classes de dados nas quais TODOS os elementos são do mesmo tipo. A classe <code>listas</code> não tem esse requisito. As listas têm posições (índices) para diferentes topos de elementos.</p>
<p>Para acessar um elemento em um vetor, utilizamos <code>[]</code>.</p>
<pre class="r"><code>vector_teste &lt;- c(5:10)
vector_teste</code></pre>
<pre><code>## [1]  5  6  7  8  9 10</code></pre>
<pre class="r"><code>vector_teste[4]</code></pre>
<pre><code>## [1] 8</code></pre>
<p>Para acessar um elemento em uma lista por meio de sua posição, utilizamos <code>[[]]</code>.</p>
<pre class="r"><code>colaborador &lt;- list(name=&quot;Renata Oliveira&quot;, ano.inicio = 2006, posicao = &quot;Professora&quot;)
colaborador</code></pre>
<pre><code>## $name
## [1] &quot;Renata Oliveira&quot;
## 
## $ano.inicio
## [1] 2006
## 
## $posicao
## [1] &quot;Professora&quot;</code></pre>
</div>
<div id="matrizes" class="section level2">
<h2>Matrizes</h2>
<p>Matrizes são um conjunto de vetores. As linhas e colunas das matrizes podem ser nomeadas. Na análise espacial de um dado vetorial, temos uma tabela de atributos em estrutura matricial. As linhas representam as feições e as colunas são os atributos dessas feições. Na representação de dados raster, linhas e colunas representam latitudes e longitudes ou células raster.</p>
<p>Uma característica distintiva da linguagem de programação R é ter sido desenvolvida para a análise de dados. E quando pensamos em análise de dados, a protagonista do show é a <em>base de dados</em> ou, como vamos conhecer a partir de agora, <strong>dataframe</strong>.</p>
<p>Durante o curso, utilizaremos poucas ou nenhuma vez matrizes. Há uma razão para isso: estamos <a href="mailto:interessad@s" class="email">interessad@s</a> sorbetudo em dados no formato de <em>data frame</em>, que é um caso específico de matriz. Ainda assim, convém rapidamente aprender sobre matrizes para, advinhe, entender um pouco mais sobre <em>data frames</em>.</p>
<p>Para matemáticos, matrizes são objetos com uma álgebra própria e parte de uma área denominada Álgebra Linear. Por exemplo, a multiplicação de matrizes, se você lembra dela de seu período de escola ou graduação, segue regras e tem propriedades diferentes da multiplicação de números. Apesar do R ter uma “gramática” para Álgebra Linear (que lembra o MATLAB e Octave), ela não nos interessa agora e a deixaremos de lado.</p>
<p>Para criarmos uma matriz, precisamos de um vetor que contenha o número de elementos a serem inseridos em uma matriz. Para uma matriz de 3 linhas e 3 colunas, precisamos de um vetor de 9 elementos, a exemplo do vetor gerado pelo comando “1:9”.</p>
<p>Há duas maneiras de “preencher” a matriz: pelas linhas (“byrow = T”) ou pelas colunas (“byrow = F”). Veja os exemplos abaixo e tente compreender o funcionamento de <em>matrix</em>:</p>
<pre class="r"><code>matrix(1:9, byrow = TRUE, nrow = 3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9</code></pre>
<pre class="r"><code>matrix(1:9, byrow = FALSE, nrow = 3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9</code></pre>
<p>Vamos a um exemplo de matriz criada a partir de 3 vetores. Os vetores abaixo representam o gasto de café de 3 pessoas de segunda a sexta-feira em uma semana determinada.</p>
<pre class="r"><code>beatriz &lt;- c(4, 5, 0, 3, 5)
pedro &lt;- c(2, 2, 2, 2, 2)
mateus &lt;- c(0, 0, 12, 0, 0)</code></pre>
<p>Vamos juntar todas os vetores em um só…</p>
<pre class="r"><code>vetor_cafe &lt;- c(beatriz, pedro, mateus)</code></pre>
<p>… e criar uma matriz de 5 linhas e 3 colunas denominada café:</p>
<pre class="r"><code>cafe &lt;- matrix(vetor_cafe, byrow = FALSE, nrow = 5)
print(cafe)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    4    2    0
## [2,]    5    2    0
## [3,]    0    2   12
## [4,]    3    2    0
## [5,]    5    2    0</code></pre>
<p>Veja que as margens da matriz não tem nomes. Vamos proceder como fizemos com vetores. Entretanto, não vamos nomear cada elemento, mas as linhas e colunas, e utilizaremos as funções <em>rownames</em> e <em>colnames</em> para a tarefa:</p>
<pre class="r"><code>fregueses &lt;- c(&quot;Beatriz&quot;, &quot;Pedro&quot;, &quot;Mateus&quot;)
dias_uteis &lt;- c(&quot;Segunda&quot;, &quot;Terca&quot;, &quot;Quarta&quot;, &quot;Quinta&quot;, &quot;Sexta&quot;)
rownames(cafe) &lt;- dias_uteis
colnames(cafe) &lt;- fregueses
print(cafe)</code></pre>
<pre><code>##         Beatriz Pedro Mateus
## Segunda       4     2      0
## Terca         5     2      0
## Quarta        0     2     12
## Quinta        3     2      0
## Sexta         5     2      0</code></pre>
<p>O processo de nomear as linhas e colunas poderia ser realizado no momento em que a matriz foi gerada com o uso do argumento <em>dimnames</em>, como no exemplo:</p>
<pre class="r"><code>cafe &lt;- matrix(vetor_cafe, byrow = FALSE, nrow = 5,
               dimnames = list(dias_uteis, fregueses))</code></pre>
<p>E se quisermos trocar as linhas pelas colunas – processo conhecido como transposição da matriz? Usamos a função <em>t</em>. Dica: <em>c</em> e <em>t</em> são funções em R. Evite criar objetos com esse nome.</p>
<pre class="r"><code>t(cafe)</code></pre>
<pre><code>##         Segunda Terca Quarta Quinta Sexta
## Beatriz       4     5      0      3     5
## Pedro         2     2      2      2     2
## Mateus        0     0     12      0     0</code></pre>
<p>Se quisermos juntar os três vetores originais como se fossem colunas, podemos usar a função <em>cbind</em>.</p>
<pre class="r"><code>cbind(beatriz, pedro, mateus)</code></pre>
<pre><code>##      beatriz pedro mateus
## [1,]       4     2      0
## [2,]       5     2      0
## [3,]       0     2     12
## [4,]       3     2      0
## [5,]       5     2      0</code></pre>
<p><em>rbind</em>, função bastante útil e que voltará várias vezes no curso, faz o mesmo tratando os vetores como linhas:</p>
<pre class="r"><code>rbind(beatriz, pedro, mateus)</code></pre>
<pre><code>##         [,1] [,2] [,3] [,4] [,5]
## beatriz    4    5    0    3    5
## pedro      2    2    2    2    2
## mateus     0    0   12    0    0</code></pre>
<p>As funções <em>rowSums</em> e <em>colSums</em>, como é de se esperar, calculam as somas de todos os elementos de cada linha e de cada coluna, respectivamente:</p>
<pre class="r"><code>rowSums(cafe)</code></pre>
<pre><code>## Segunda   Terca  Quarta  Quinta   Sexta 
##       6       7      14       5       7</code></pre>
<pre class="r"><code>colSums(cafe)</code></pre>
<pre><code>## Beatriz   Pedro  Mateus 
##      17      10      12</code></pre>
<p>Combinando as funções de soma com as de combinação (sic), podemos gerar os totais nas margens da matriz:</p>
<pre class="r"><code>Total_Coluna &lt;- colSums(cafe)
cafe2 &lt;- rbind(cafe, Total_Coluna)
Total_Linha &lt;- rowSums(cafe2)
cafe2 &lt;- cbind(cafe2, Total_Linha)
print(cafe2)</code></pre>
<pre><code>##              Beatriz Pedro Mateus Total_Linha
## Segunda            4     2      0           6
## Terca              5     2      0           7
## Quarta             0     2     12          14
## Quinta             3     2      0           5
## Sexta              5     2      0           7
## Total_Coluna      17    10     12          39</code></pre>
<p>Como com vetores, podemos fazer operações aritméticas (veja que não estamos falando de Álgebra Linear) com matrizes. Por exemplo, para transformar os gastos com café em doláres (cotação = 3.2):</p>
<pre class="r"><code>cafe / 3.2</code></pre>
<pre><code>##         Beatriz Pedro Mateus
## Segunda  1.2500 0.625   0.00
## Terca    1.5625 0.625   0.00
## Quarta   0.0000 0.625   3.75
## Quinta   0.9375 0.625   0.00
## Sexta    1.5625 0.625   0.00</code></pre>
<p>Podemos também relizar operações entre matrizes de mesmas dimensões que considerem os elementos de forma pareada, tal como com vetores. Usando as duas matrizes do começo deste tópico:</p>
<pre class="r"><code>matrix(1:9, byrow = TRUE, nrow = 3) + matrix(1:9, byrow = FALSE, nrow = 3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    2    6   10
## [2,]    6   10   14
## [3,]   10   14   18</code></pre>
<p>Tanto sobre matriz para chegarmos ao que realmente importa: subconjuntos de matrizes. Com vetores, usamos colchetes para produzirmos subconjuntos. As regras que aprendemos para vetores valem para matrizes. A diferença é que matrizes – e também <em>data frames</em> – são objetos com duas dimensões (linhas e colunas). Portanto, ao extrairmos um subconjunto, precisamos informar as duas dimensões nos colchetes, primeiro linha, depois coluna, separadas por vírgula. Se deixamos uma das dimensões em branco, estamos selecionando todos os elementos daquela dimensão.</p>
<p>Vamos a uma série de exemplos para compreender as regras de subconjunto de matrizes.</p>
<p>Selecionar toda a segunda coluna:</p>
<pre class="r"><code>cafe[, 2]</code></pre>
<pre><code>## Segunda   Terca  Quarta  Quinta   Sexta 
##       2       2       2       2       2</code></pre>
<p>Selecionar toda a terceira linha:</p>
<pre class="r"><code>cafe[3, ]</code></pre>
<pre><code>## Beatriz   Pedro  Mateus 
##       0       2      12</code></pre>
<p>Selecionar o elemento da linha 1 e coluna 3:</p>
<pre class="r"><code>cafe[1, 3]</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Selecionar os elementos 4 e 5 da coluna 1:</p>
<pre class="r"><code>cafe[4:5, 1]</code></pre>
<pre><code>## Quinta  Sexta 
##      3      5</code></pre>
<p>Selecionar os elementos 1, 3 e 5 da coluna 3:</p>
<pre class="r"><code>cafe[c(1,3,5), 3]</code></pre>
<pre><code>## Segunda  Quarta   Sexta 
##       0      12       0</code></pre>
<p>Selecionar o elemento 4 das colunas 2 e 3:</p>
<pre class="r"><code>cafe[4, 2:3]</code></pre>
<pre><code>##  Pedro Mateus 
##      2      0</code></pre>
<p>Selecionar a segunda e terça-feira de Pedro:</p>
<pre class="r"><code>cafe[c(&quot;Segunda&quot;, &quot;Terca&quot;), &quot;Pedro&quot;]</code></pre>
<pre><code>## Segunda   Terca 
##       2       2</code></pre>
<p>Selecionar a quarta-feira de todos:</p>
<pre class="r"><code>cafe[&quot;Quarta&quot;,]</code></pre>
<pre><code>## Beatriz   Pedro  Mateus 
##       0       2      12</code></pre>
</div>
<div id="dataframes" class="section level2">
<h2>Dataframes</h2>
<p><code>Data frames</code> e <code>tibble</code> são estruturas tabulares de dados que, diferentemente das matrizes (<code>matrix</code>), permitem representar diferentes atributos (e tipos de dados) em diferentes colunas. Esses tipos de classes são utilizadas para organizar dados espaciais (pontos, linhas, áreas e pixels).</p>
<p>Por esta razão, em vez de aprender como fazer aritmética, elaborar funções ou executar loops para repetir tarefas e outros aspectos básicos da linguagem, vamos começar olhando para o R como um software concorrente dos demais utilizados para análise de dados em ciências sociais, como SPSS, Stata, SAS e companhia.</p>
<p>As principais características de um dataframe são: (1) cada coluna representa uma variável (ou característica) de um conjunto de observações; (2) cada linha representa uma observação e contém os valores de cada variável para tal observação. Vejamos um exemplo:</p>
<table>
<thead>
<tr class="header">
<th>Candidato</th>
<th align="center">Partido</th>
<th align="right">Votos</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Beatriz</td>
<td align="center">PMDB</td>
<td align="right">350</td>
</tr>
<tr class="even">
<td>Danilo</td>
<td align="center">SOL</td>
<td align="right">1598</td>
</tr>
<tr class="odd">
<td>Pedro</td>
<td align="center">PTB</td>
<td align="right">784</td>
</tr>
<tr class="even">
<td>Davi</td>
<td align="center">PSD</td>
<td align="right">580</td>
</tr>
<tr class="odd">
<td>Mateus</td>
<td align="center">PV</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
<p>Com a função <em>data</em> podemos carregar um conjunto de dados disponível na sua sessão de R. Utilizaremos a base <em>mtcars</em>, que contém dados da revista <em>Motor Trend US</em> sobre características (variáveis) de 32 automóveis (esse é um dos conjuntos de dados mais populares em cursos introdutórios de R).</p>
<pre class="r"><code>data(mtcars)</code></pre>
<p>Pronto! Logo mais veremos como abrir conjuntos de dados de outras fontes (arquivos de texto, outros softwares, etc), mas já podemos começar a trabalhar com <em>data frames</em>.</p>
<p>Antes de avançar, vamos usar o <strong>help</strong> (documentação) do R para descobrir o que há no <em>data frame</em> chamado <em>mtcars</em>:</p>
<pre class="r"><code>?mtcars</code></pre>
<pre><code>## starting httpd help server ... done</code></pre>
<p>Se quiseremos olhar para os dados que acabamos de carregar utilizamos a função <em>View</em> (com V maiúsculo, algo pouco usual em R):</p>
<pre class="r"><code>View(mtcars)</code></pre>
<div id="do-editor-de-planilhas-ao-r---parte-1" class="section level3">
<h3>Do editor de planilhas ao R - parte 1</h3>
<p>A partir desse ponto no curso vamos resistir à tentação de “olhar” para os dados. O hábito de quem utiliza com editores de planilha como MS Excel ou Libre Office, ou ainda com algums softwares de análise de dados como SPSS e Minitab, é trabalhar “olhando” para os dados, ou seja, para os valores de cada célula de uma base dados.</p>
<p>Você perceberá em pouco tempo que isso não é necessário. Na verdade, é contraproducente. Nas primeiras aulas vamos nos munir de ferramentas que nos permitirão conhecer os dados sem olhá-los diretamente.</p>
<div id="head-no-lugar-de-view" class="section level4">
<h4>Head no lugar de View</h4>
<p>Por exemplo, podemos substituir a função <em>View</em> pela função <em>head</em>. Veja o resultado:</p>
<pre class="r"><code>head(mtcars)</code></pre>
<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<p>Com apenas as 6 primeiras linhas do <em>data frame</em> temos noção de todo o conjunto. Sabemos rapidamente que os nomes dos carros são o nome de cada uma das linhas, e que o nome das colunas indicam qual característica está armazenada coluna (lembra-se da documentação de <em>mtcars</em> que você acabou de ler).</p>
<p>Alternativamente, podemos usar a função <em>str</em> (atalho para “structure”):</p>
<pre class="r"><code>str(mtcars)</code></pre>
<pre><code>## &#39;data.frame&#39;:    32 obs. of  11 variables:
##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
##  $ disp: num  160 160 108 258 360 ...
##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
##  $ qsec: num  16.5 17 18.6 19.4 17 ...
##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...</code></pre>
<p>Com <em>str</em> sabemos qual é a lista de variáveis (colunas) no <em>data frame</em>, de qual tipo são – no caso, todas são numéricas e vamos falar sobre esse tema mais tarde – e os primeiros valores de cada uma, além do número total de observações e variáveis mostrados no topo do <strong>output</strong>.</p>
<p>Há outras maneiras de obter o número linhas e colunas de um <em>data frame</em>:</p>
<pre class="r"><code>nrow(mtcars)</code></pre>
<pre><code>## [1] 32</code></pre>
<pre class="r"><code>ncol(mtcars)</code></pre>
<pre><code>## [1] 11</code></pre>
<pre class="r"><code>dim(mtcars)</code></pre>
<pre><code>## [1] 32 11</code></pre>
<p><em>nrow</em> retorna o número de linhas; <em>ncol</em>, o de coluna; <em>dim</em> as dimensões (na ordem linha e depois coluna) do objeto.</p>
<p><em>names</em>, por sua vez, retorna os nomes das variáveis do <em>data frame</em></p>
<pre class="r"><code>names(mtcars)</code></pre>
<pre><code>##  [1] &quot;mpg&quot;  &quot;cyl&quot;  &quot;disp&quot; &quot;hp&quot;   &quot;drat&quot; &quot;wt&quot;   &quot;qsec&quot; &quot;vs&quot;   &quot;am&quot;   &quot;gear&quot;
## [11] &quot;carb&quot;</code></pre>
</div>
<div id="argumentos-ou-parâmetros-das-funções" class="section level4">
<h4>Argumentos ou parâmetros das funções</h4>
<p>Note que em todas as funções que utilizamos até agora, <em>mtcars</em> está dentro do parêntesis que segue o nome da função. Essa <strong>sintax</strong> é característica das funções de R. O que vai entre parêntesis são os <strong>argumentos</strong> ou <strong>parâmetros</strong> da função, ou seja, os “inputs” que serão transformados.</p>
<p>Uma função pode receber mais de um argumento. Pode também ter argumentos não obrigatórios, ou seja, para os quais não é necessário informar nada se você não quiser alterar os valores pré-definidos. Por exemplo, a função <em>head</em> contém o argumento <em>n</em>, que se refere ao número de linhas a serem <strong>impressas</strong> na tela, pré-estabelecido em 6 (você pode conhecer os argumentos da função na documentação do R usando <em>?</em> antes do nome da função). Para alterá-lo para 10, por exemplo, basta fazer:</p>
<pre class="r"><code>head(x = mtcars, n = 10)</code></pre>
<pre><code>##                    mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
## Duster 360        14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
## Merc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
## Merc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## Merc 280          19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4</code></pre>
<p><em>x</em> é o argumento que já havíamos utilizado anteriormente e indica em que objeto a função <em>head</em> será aplicada. Dica: você pode omitir tanto “x =” quanto “n =” se você já conhecer a ordem de cada argumento no uso da função. Veja que neste caso estamos utilizando o símbolo “=” sem fazer a atribuição de dados a um objeto, mas para atribuir valores (ou objetos) aos argumento de uma função. Para não haver confusão é preferível usar o símbolo “&lt;-” para atribuição e o “=” para as demais situações.</p>
<p>A classe <code>data.frame</code> no R é composta por uma série de vetores de <strong>comprimento igual</strong> (número de observações) que juntos formam uma estrutura de dados bi-dimensional. Cada vetor registra valores de um atributo específico. Essa é a classe de dados mais comumente utilizada para armazenar dados no R.</p>
<pre class="r"><code>df &lt;- data.frame(dist=seq(0, 400, 100), city=c(&quot;Belo Horizonte&quot;, &quot;São Paulo&quot;, &quot;Rio de Janeiro&quot;, &quot;Brasília&quot;, &quot;Salvador&quot;))
str(df)</code></pre>
<pre><code>## &#39;data.frame&#39;:    5 obs. of  2 variables:
##  $ dist: num  0 100 200 300 400
##  $ city: chr  &quot;Belo Horizonte&quot; &quot;São Paulo&quot; &quot;Rio de Janeiro&quot; &quot;Brasília&quot; ...</code></pre>
<blockquote>
<p>A função <code>seq</code> possibilita a criação de uma sequência de dados por meio de três parâmetros: seq(<code>valor_inicial</code>, <code>valor_final</code>, <code>intervalo</code>).</p>
</blockquote>
<p>Tibbles e data.frames não são muito diferentes. Há alguns detalhes quanto à transformação de dados na criação dessas classes, mas, em linhas gerais, a estrutura de dados em <code>tibble</code> é mais eficiente e organizada.</p>
<p>As seguintes funções são adequadas tanto para <code>data.frames</code> como para <code>tibble</code>:<br />
<code>names()</code><br />
<code>colnames()</code><br />
<code>rownames()</code><br />
<code>length()</code><br />
<code>ncol()</code><br />
<code>nrow()</code></p>
<blockquote>
<p>Explore a documentação do <code>tibble</code> em: <code>vignette("tibble")</code></p>
</blockquote>
<p>Os objetos dessas duas classes podem ser selecionados por meio da estrutura <code>data.frame[linha, coluna]</code>, na qual os parâmetros linhas e coluna são os índices desses elementos.</p>
<p>Para combinar <code>data.frame</code> e <code>tibble</code> por linhas ou colunas utilizamos, respectivamente, as funções <code>rbind()</code> e <code>cbind()</code>.</p>
<p>Até aqui, já ficou claro que a escolha ou identificação dos tipos e das classes de dados espaciais e não espaciais é muito importante para sua análise.</p>
<p>Algumas funções para manipulação de dataframes:</p>
<p>head() # - Mostra as primeiras 6 linhas.<br />
tail() # - Mostra as últimas 6 linhas.<br />
dim() # - Número de linhas e de colunas.<br />
names() # - Os nomes das colunas (variáveis).<br />
str() # - Estrutura do data.frame. Mostra, entre outras coisas, as classes de cada coluna.<br />
cbind() # - Acopla duas tabelas lado a lado.<br />
rbind() # - Empilha duas tabelas.</p>
<hr />
<p>Créditos:<br />
O conteúdo deste documento é, em parte, originalmente produzido por Leonardo S. Barone e Vanderlei de Bastiani. Muito obrigada pelo trabalho e por compartilharem esses documentos!</p>
<p><a href="https://github.com/leobarone/FLS6397/blob/master/tutorials/tutorial2.Rmd" class="uri">https://github.com/leobarone/FLS6397/blob/master/tutorials/tutorial2.Rmd</a></p>
<p><a href="https://vanderleidebastiani.github.io/tutoriais/Introducao_ao_R.html#sobre_o_r" class="uri">https://vanderleidebastiani.github.io/tutoriais/Introducao_ao_R.html#sobre_o_r</a></p>
</div>
</div>
</div>
</div>
